# Lesson 01

### Git

Система контроля версий (Version Control System, VCS) — это инструмент, который используется программистами для отслеживания и управления изменениями в коде или других файлах проекта. Она позволяет сохранять различные версии файлов и возвращаться к ним при необходимости, а также эффективно сотрудничать в команде. Рассмотрим более подробно, что делает систему контроля версий неотъемлемой частью разработки программного обеспечения.

### Отслеживание изменений

- **История изменений**: VCS позволяет разработчикам видеть полную историю изменений каждого файла, а также узнать, кто, когда и почему сделал определенные изменения.
- **Сравнение версий**: Можно сравнивать различные версии файла, чтобы понять, какие изменения были внесены и как они повлияли на проект.
- **Откат изменений**: Если внесенные изменения вызывают проблемы, можно легко вернуться к предыдущей, стабильной версии файла или проекта в целом.

### Поддержка параллельной разработки

- **Ветвление и слияние**: Разработчики могут работать над разными функциями или частями проекта одновременно, создавая отдельные ветки для каждой задачи. После завершения работы ветки могут быть слияны, интегрируя все изменения в основную кодовую базу.
- **Разрешение конфликтов**: Когда два разработчика изменяют одну и ту же часть кода одновременно, система контроля версий помогает обнаружить конфликты и позволяет разработчикам их разрешить.

### Упрощение сотрудничества

- **Общий доступ к коду**: В распределенных системах контроля версий, таких как Git, каждый участник имеет полную копию репозитория на своем компьютере, что обеспечивает гибкость в работе и облегчает совместное использование кода.
- **Контроль изменений**: Команды могут отслеживать, кто и когда вносил изменения в код, что помогает координировать разработку и облегчает обнаружение и исправление ошибок.

### Воспроизводимость и аудит

- **Воспроизводимость**: Возможность восстановить любую версию проекта позволяет воспроизвести и анализировать состояние программы на любом этапе ее развития.
- **Аудит**: История изменений в VCS может служить важным инструментом для аудита кода, позволяя отслеживать изменения для соответствия стандартам качества и безопасности.

В целом, система контроля версий — это критически важный инструмент для любого проекта по разработке программного обеспечения, позволяя командам эффективно сотрудничать, управлять изменениями и поддерживать высокий уровень качества и стабильности продукта.

Системы контроля версий (VCS) прошли долгий путь развития, преобразовываясь из простых инструментов для отслеживания изменений файлов в мощные системы, поддерживающие сложные рабочие процессы и большие команды разработчиков. Давайте рассмотрим краткую историю развития систем контроля версий, от локальных к централизованным и затем к распределенным системам.

### Локальные системы контроля версий

В начале компьютерной эры разработчики сохраняли копии своих файлов вручную в разные моменты времени. Этот процесс был подвержен ошибкам, и с течением времени появилась потребность в более организованной системе.

- **SCCS (Source Code Control System)**: Одной из первых систем контроля версий, предназначенной для отслеживания изменений в исходном коде, была SCCS, разработанная в начале 1970-х годов. Она позволяла программистам сохранять предыдущие версии файлов и просматривать историю изменений.

- **RCS (Revision Control System)**: В 1980-х годах RCS стала популярной альтернативой SCCS, предоставляя более улучшенные средства для управления версиями файлов. RCS также работала локально и была ограничена одним пользователем.

Централизованные и распределённые системы контроля версий (VCS) представляют собой два основных подхода к управлению изменениями в коде и других типах файлов в проектах разработки программного обеспечения. Давайте подробно рассмотрим ключевые различия между этими двумя типами систем.

### Централизованные системы контроля версий (Centralized VCS)

Примеры: Subversion (SVN), Concurrent Versions System (CVS).

**Основная концепция**: В централизованных VCS есть один центральный сервер, хранящий все файлы и историю их изменений, и клиенты, которые скачивают файлы с сервера для работы с ними.

- **Одна центральная копия**: Вся история проекта хранится на центральном сервере. Разработчики получают копии нужных файлов для работы, но не всей истории изменений.

- **Необходимость подключения к сети**: Для выполнения большинства операций (коммит, обновление, слияние) необходимо подключение к центральному серверу.

- **Линейная история изменений**: Централизованные системы обычно поддерживают более линейную историю изменений, что может упростить отслеживание изменений, но ограничивает гибкость в управлении версиями.

- **Риск одной точки отказа**: Если центральный сервер выйдет из строя, это может временно остановить работу всей команды и создать риск потери данных, если нет резервного копирования.

### Распределённые системы контроля версий (Distributed VCS)

Примеры: Git, Mercurial.

**Основная концепция**: В распределённых VCS каждый разработчик имеет локальную копию всего репозитория, включая всю историю изменений, что позволяет работать с проектом автономно и предоставляет дополнительную степень гибкости.

- **Локальные репозитории**: Разработчики имеют полные копии репозитория на своих машинах, включая всю историю изменений, что позволяет им работать автономно и выполнять многие операции без доступа к сети.

- **Автономная работа**: Коммиты, просмотр истории и другие операции могут выполняться локально, без необходимости постоянного подключения к сети.

- **Гибкость ветвления и слияния**: Распределенные VCS обычно предлагают более продвинутые инструменты для ветвления и слияния, позволяя разработчикам легко создавать и управлять ветками, а также объединять изменения из разных веток.

- **Отсутствие одной точки отказа**: Поскольку каждый разработчик имеет полную копию репозитория, отказ одного компьютера или потеря данных не ведет к потере всего проекта. Восстановление данных возможно с помощью любой другой копии репозитория.

- **Синхронизация и обмен изменениями**: В распределённых системах разработчики могут обмениваться изменениями, синхронизируя свои локальные репозитории с другими репозиториями. Это может быть центральный репозиторий, как на GitHub или Bitbucket, или репозиторий другого разработчика. Это обеспечивает гибкость в совместной работе и варианты интеграции изменений.

- **Независимость от центрального сервера**: Хотя в распределённой системе может использоваться "центральный" репозиторий для координации работы, каждый локальный репозиторий полностью независим и содержит всю историю проекта. Это значит, что работа может продолжаться даже при отсутствии доступа к этому центральному репозиторию.

- **Улучшенная производительность**: Поскольку большинство операций выполняется локально, распределённые VCS часто работают быстрее, чем централизованные, особенно при работе с историей и ветвлением.

- **Более сложное ветвление и слияние**: Распределённые системы как Git предоставляют мощные средства для управления ветками и слиянием изменений, что позволяет разработчикам создавать сложные рабочие процессы, например, Git Flow.

В целом, выбор между централизованными и распределёнными системами контроля версий зависит от конкретных потребностей проекта, команды и рабочих процессов. Распределённые системы, как правило, предлагают большую гибкость и масштабируемость, что делает их популярным выбором для многих современных проектов по разработке программного обеспечения.


Git — это распределённая система контроля версий, которая применяет ряд уникальных концепций и подходов, отличающих её от других систем контроля версий. Давайте подробно рассмотрим основные принципы работы Git с примерами для лучшего понимания.

### 1. Снимки состояния, а не разности

В отличие от некоторых других систем контроля версий, которые сохраняют информацию в виде списка изменений (диффов) между версиями, Git сохраняет каждую версию как точный снимок состояния всех файлов в репозитории на момент коммита. Если файл не изменялся, Git просто сохраняет ссылку на предыдущую копию файла.

**Пример**: Представьте, что у вас есть проект с тремя файлами:

- В коммите `A` вы создаёте файлы `file1`, `file2`, `file3`.
- В коммите `B` вы изменяете `file1`. Git сохранит изменённую версию `file1` и ссылки на `file2` и `file3` из коммита `A`.
- В коммите `C` вы изменяете `file2`. Git сохранит новую версию `file2`, ссылку на `file1` из коммита `B` и ссылку на `file3` из коммита `A`.

### 2. Почти все операции — локальные

Большинство действий в Git происходит локально, без необходимости взаимодействия с удалённым репозиторием. Это значительно ускоряет работу и позволяет выполнять многие операции вне сети.

**Пример**: Когда вы просматриваете историю коммитов (`git log`), вы работаете с локальной базой данных. Изменение веток (`git checkout`), добавление коммитов (`git commit`) и многие другие операции также происходят мгновенно, не требуя сетевого взаимодействия.

### 3. Интегрированная целостность данных

Git активно использует хеширование, применяя SHA-1 хеш для идентификации объектов (коммитов, деревьев, файлов и т.д.) в репозитории. Это обеспечивает целостность данных проекта и защиту от их изменения или повреждения.

**Пример**: Каждый коммит в Git идентифицируется по хешу. Если вы попытаетесь изменить что-то в истории, хеш коммита изменится, что сделает очевидным факт вмешательства.

### 4. Три состояния файла

Git определяет три основных состояния, в которых может находиться файл: modified (изменённый), staged (подготовленный), и committed (зафиксированный).

- **Modified**: Файл изменён в рабочем каталоге, но ещё не добавлен в индекс.
- **Staged**: Изменённый файл добавлен в индекс и готов к коммиту.
- **Committed**: Данные безопасно хранятся в вашей локальной базе данных.

**Пример**: Представим, что вы редактируете файл `file1`. После сохранения изменений файл находится в состоянии Modified. Выполнив `git add file1`, вы переведёте его в состояние Staged. Когда вы сделаете коммит, файл перейдёт в состояние Committed.

Git отличается от других систем контроля версий рядом уникальных особенностей, которые обеспечивают его популярность и широкое применение в индустрии разработки программного обеспечения. Давайте рассмотрим ключевые отличия Git от других систем контроля версий:

### 1. Распределённая архитектура

В отличие от централизованных систем контроля версий (например, SVN), каждый репозиторий в Git является полноценной копией всего проекта, включая всю историю изменений. Это означает, что каждый разработчик имеет полную локальную копию репозитория, что позволяет работать с проектом автономно и без постоянного доступа к сети.

### 2. Снимки состояния вместо разностей

Git хранит данные как серию снимков состояния файловой системы. В отличие от систем, основанных на хранении разностей между последовательными версиями файла (как, например, в SVN), Git для каждого коммита сохраняет снимок всех файлов, которые были в нём изменены. Если файл не изменялся, Git сохраняет ссылку на предыдущую копию файла.

### 3. Эффективность

Благодаря своей архитектуре и методам хранения данных, Git чрезвычайно эффективен в плане скорости и объема занимаемого пространства, особенно при работе с большими проектами. Операции, такие как сравнение, слияние и извлечение истории изменений, выполняются очень быстро.

### 4. Ветвление и слияние

Git предоставляет мощные и гибкие инструменты для ветвления и слияния, делая эти операции быстрыми и удобными. Создание новой ветки в Git практически мгновенно, а слияние веток обычно происходит автоматически и эффективно благодаря алгоритмам, лежащим в основе Git.

### 5. Целостность данных

Git использует механизм хеширования (SHA-1), чтобы гарантировать целостность каждого файла и коммита в репозитории. Это означает, что невозможно изменить содержимое файла или коммита без того, чтобы Git об этом узнал.

### 6. Легкость восстановления

Благодаря тому, что каждый клон репозитория является полной его копией, восстановление информации после сбоя или потери данных обычно проще, чем в централизованных системах, где для восстановления необходим доступ к центральному серверу.

### 7. Мощная система ветвления

Ветвление в Git — это одна из его ключевых особенностей. Git позволяет легко и быстро создавать, удалять и сливать ветки, облегчая параллельную работу над различными функциями и версиями проекта.

Эти особенности делают Git предпочтительным выбором для многих команд и проектов, от маленьких личных проектов до крупных корпоративных разработок.


###  Многопоточность. Введение
**Лекция 1: Общие сведения**

1. **Введение**
    - История вычислительной техники начинается с механических вычислительных машин XIX века.
    - XX век принес компьютеры в современном понимании.
    - Развитие технологий привело к сокращению размеров ЭВМ и увеличению их производительности и энергоэффективности.
    - Возникновение микросборок и микросхем.
    - Формулировка «закона» Мура о росте количества транзисторов на кристалле.

2. **Основные элементы в компьютере**
    - Процессор как центральный элемент, выполняющий инструкции программ.
    - Эволюция процессоров от одноядерных к многоядерным для повышения производительности.

3. **Краткое описание работы процессора**
    - АЛУ (арифметико-логическое устройство) как главный элемент процессора.
    - Регистры, шины данных и адреса, дешифратор команд.
    - Основные операции АЛУ и принципы их выполнения.

4. **Поддержка на уровне операционной системы**
    - ОС распределяет процессорное время между процессами разными способами: простое переключение задач, кооперативная и вытесняющая многозадачность.
    - Различие между кооперативной и вытесняющей многозадачностью по способу распределения процессорного времени.

5. **Концепции вычислений**
    - Последовательные вычисления, где задачи выполняются одна за другой.
    - Параллельные вычисления, позволяющие выполнять множество задач одновременно на многоядерных процессорах.

6. **Процессы и потоки**
    - Определение процесса и потока, их особенности и различия.
    - Процессы как независимые единицы с собственными ресурсами.
    - Потоки как единицы выполнения внутри процесса, делящие его ресурсы.
    - Отличия потоков от процессов по набору информации, использованию памяти и скорости переключения.

7. **Многопоточность и алгоритм разделения времени**
    - Алгоритм time-slicing для распределения процессорного времени между потоками.
    - Различие между имитацией параллельности в одноядерных системах и реальной параллельностью в многоядерных системах.
    - Влияние многопоточности на производительность и ресурсы системы.

8. **Преимущества и недостатки многопоточности**
    - Улучшение адаптивности и производительности приложений благодаря многопоточности.
    - Сложности проектирования и отладки многопоточных приложений.
    - Проблемы с синхронизацией данных и переключением контекста между потоками.


#### 2.1 Средства для работы с многопоточностью в Java
- **Java 1.0**: `Thread`, `Runnable`, `synchronized`, `wait()`, `notify()`, `notifyAll()`.
- **Java 1.5**: Пакет `java.util.concurrent` с расширенными возможностями.
- **Java 1.8**: `CompletableFuture` для асинхронных задач и их комбинирования.

#### Модели многопоточных программ
- Синхронизация, блокировки, `volatile`.
- Транзакционная память, рекурсивный параллелизм.
- Модель акторов: объекты как потоки обмениваются сообщениями.
#### Проблемы, решаемые многопоточностью (продолжение)

1. **Одновременное выполнение нескольких действий**: Многопоточность позволяет программе выполнять несколько задач одновременно, улучшая интерактивность и отзывчивость.
2. **Ускорение вычислений**: Использование многопоточности позволяет эффективно распределить задачи между ядрами процессора, сокращая общее время выполнения программы.

#### Проблемы, создаваемые многопоточностью

1. **Взаимная блокировка (Deadlock)**: Состояние, при котором два или более потоков ждут ресурсы, захваченные друг другом, и не могут продолжить выполнение.
2. **Состояние гонки (Race Condition)**: Ошибка проектирования, когда работа системы становится зависимой от последовательности выполнения потоков. Это может привести к непредсказуемому поведению программы.

#### Что должен знать Java-разработчик о многопоточности

**Уровень Junior**:
- Основы реализации многопоточности в Java.
- Синтаксические конструкции, связанные с потоками.
- Основы пакета `java.util.concurrent`.

**Уровень Middle**:
- Глубокое понимание стандартных библиотек и инструментов Java для многопоточности.
- Понимание многопоточности в контексте Spring.
- Способность самостоятельно разрабатывать многопоточный функционал.

**Уровень Senior**:
- Продвинутое знание инструментов и библиотек для многопоточности.
- Понимание применения инструментов многопоточности в различных сценариях.
- Умение архитектурно интегрировать многопоточность в приложения.


