# Lesson 02

Давайте рассмотрим несколько примеров кода на Java, которые демонстрируют концепции, обсуждаемые в лекции.

1. **Создание и запуск потоков в Java**
   В Java потоки можно создавать двумя способами: наследуясь от класса `Thread` или реализуя интерфейс `Runnable`.

    - **Пример с наследованием от класса Thread:**

      ```java
      class MyThread extends Thread {
          public void run() {
              System.out.println("Поток запущен: " + Thread.currentThread().getName());
          }
      }
 
      public class Main {
          public static void main(String[] args) {
              MyThread thread = new MyThread();
              thread.start();
          }
      }
      ```

    - **Пример с реализацией интерфейса Runnable:**

      ```java
      class MyRunnable implements Runnable {
          public void run() {
              System.out.println("Поток запущен: " + Thread.currentThread().getName());
          }
      }
 
      public class Main {
          public static void main(String[] args) {
              Thread thread = new Thread(new MyRunnable());
              thread.start();
          }
      }
      ```

2.  **Средства для работы с многопоточностью в Java и модели многопоточных программ**

1. **Инструменты многопоточности в Java:**
    - В первых версиях Java средства многопоточности ограничивались классом `Thread`, интерфейсом `Runnable`, ключевым словом `synchronized`, и методами `wait()`, `notify()`, `notifyAll()` в классе `Object`.
    - С Java 1.5 появился пакет `java.util.concurrent`, вносящий значительные улучшения и расширения в инструментарий для работы с многопоточностью.
    - В Java 1.8 был добавлен класс `CompletableFuture` для создания асинхронных задач и их комбинирования.

2. **Модели многопоточного программирования:**
    - **Синхронизация и блокировки:** использование `synchronized` и `volatile` для управления доступом к общим ресурсам и обеспечения видимости изменений переменных между потоками.
    - **Транзакционная память:** обеспечивает абстракцию, позволяющую управлять доступом к памяти в многопоточных приложениях, упрощая разработку за счет автоматического контроля за блокировками и изменениями.
    - **Модель акторов:** в этой модели каждый объект (актор) является отдельным потоком и взаимодействует с другими акторами исключительно посредством обмена сообщениями, что уменьшает риск гонок данных и упрощает разработку.

3. **Способы организации многопоточности в программах:**
    - Потоки могут работать независимо друг от друга, не взаимодействуя напрямую.
    - Потоки могут активно взаимодействовать друг с другом, координируя выполнение задач.
    - Потоки могут работать независимо, а затем собирать свои результаты в единый выходной результат.

4. **Потоки в Java:**
    - `Thread` — базовый класс для создания потоков.
    - Создание потоков может происходить через наследование от `Thread` и переопределение метода `run()` или через реализацию интерфейса `Runnable` с последующей передачей его экземпляра в конструктор `Thread`.
    - Предпочтительнее использовать `Runnable` для создания потоков, так как это обеспечивает большую гибкость и позволяет избежать ограничений, связанных с наследованием.

5. **Управление потоками:**
    - Метод `start()` запускает поток, в то время как вызов `run()` просто выполняет код в текущем потоке.
    - Можно устанавливать приоритеты потоков, используя метод `setPriority()`, что влияет на распределение времени процессора между потоками.
    - Потоки-демоны (`daemon threads`) — это служебные потоки, которые не препятствуют завершению работы JVM.
    - Группировка потоков через `ThreadGroup` позволяет управлять группами потоков как единым целым.
    - Метод `join()` позволяет одному потоку ожидать завершения работы другого потока.
    - Приостановка выполнения потока может быть реализована с помощью `Thread.sleep()`


###  "Остановка и прерывание потоков в Java"

**Засыпание потока (Sleep)**: Потоки могут быть приостановлены на определённое время с использованием метода `Thread.sleep(millis)`, где `millis` — время в миллисекундах.

**Прерывание потока (Interrupt)**: Потоки могут быть прерваны в любой момент их выполнения с помощью метода `interrupt()`. Это важно для безопасного завершения потока.

### Примеры кода

#### Засыпание потока с `Thread.sleep()`
```java
class SleepExample {
    public static void main(String[] args) {
        Runnable sleepTask = () -> {
            try {
                // Поток засыпает на 1 минуту
                Thread.sleep(1000 * 60);
                System.out.println("Проснулся после 1 минуты");
            } catch (InterruptedException e) {
                System.out.println("Сон прерван");
            }
        };

        Thread thread = new Thread(sleepTask);
        thread.start();
    }
}
```

#### Прерывание потока
```java
class InterruptExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    System.out.println("Поток работает");
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                System.out.println("Поток прерван");
                // Восстанавливаем прерывание
                Thread.currentThread().interrupt();
            }
        });

        thread.start();

        // Даем потоку время на выполнение
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Прерываем поток
        thread.interrupt();
    }
}
```

#### Обработка `InterruptedException`
```java
class InterruptedExceptionHandling {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            while (!Thread.interrupted()) {
                try {
                    // Выполнение каких-то действий
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("Обработка InterruptedException");
                    // Прерываем поток
                    Thread.currentThread().interrupt();
                }
            }
        });

        thread.start();

        // Прерываем поток после 3 секунд
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
```

#### Прерывание потока во время блокирующей операции
```java
class BlockingOperationInterrupt {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    // Эмуляция блокирующей операции
                    System.out.println("Ожидание ввода...");
                    Thread.sleep(10000);
                }
            } catch (InterruptedException e) {
                System.out.println("Блокирующая операция прервана");
                Thread.currentThread().interrupt();
            }
        });

        thread.start();

        // Прерываем поток через 2 секунды
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
```

### Метод join() в Java

#### Введение в join()
Метод `join()` в Java позволяет одному потоку ожидать завершения другого потока. Это особенно полезно в многопоточных программах, где один поток должен дождаться завершения других потоков перед продолжением выполнения. Этот метод блокирует текущий поток до тех пор, пока целевой поток, на котором был вызван `join()`, не завершится.

#### Примеры использования метода join()

##### Пример 1: Синхронизация счетчика
```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

class MyRunnable implements Runnable {
    private final Counter counter;

    public MyRunnable(Counter counter) {
        this.counter = counter;
    }

    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread thread1 = new Thread(new MyRunnable(counter));
        Thread thread2 = new Thread(new MyRunnable(counter));
        thread1.start();
        thread2.start();
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Count: " + counter.getCount());
    }
}
```
В этом примере два потока увеличивают счетчик в общем объекте `Counter`. Главный поток дожидается их завершения, используя `join()`, прежде чем выводить итоговое значение счетчика.

##### Пример 2: Подсчет суммы в потоках
```java
class MyThread extends Thread {
    private int result;

    public void run() {
        result = 0;
        for (int i = 1; i <= 10; i++) {
            result += i;
        }
    }

    public int getResult() {
        return result;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        int result = thread1.getResult() + thread2.getResult();
        System.out.println("Result: " + result);
    }
}
```
Здесь два потока вычисляют сумму чисел, а главный поток ожидает их завершения, чтобы суммировать их результаты.

##### Пример 3: Ожидание выполнения потока
```java
public class App {
    public static void main(String[] args) throws InterruptedException {
        var threadTwo = new Thread(() -> {
            try {
                Thread.sleep(2000);
                int counter = 0;
                for (int i = 0; i < 1000; i++) {
                    counter++;
                }
                var thread = Thread.currentThread().getName();
                System.out.println(thread + " has finished its execution, counter = " + counter);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
        }, "Counter thread");
        threadTwo.start();
        threadTwo.join(); // Ожидание завершения threadTwo
        System.out.println("Main method executing");
    }
}
```
В этом случае `threadTwo` выполняет подсчет, и основной поток (`main`) ожидает его завершения перед выводом сообщения.

#### Разница между методами `run()` и `start()`
- `run()`: Вызывает код в текущем потоке.
- `start()`: Запускает код в новом потоке.

#### Важные моменты использования потоков
- Не запускайте потоки из конструкторов классов, это может привести к неожиданным результатам, особенно при использовании фреймворков, которые создают прокси-объекты (например, Spring).
- Используйте осмыслен

### Потоки и Демоны в Java

- В Java существуют пользовательские потоки (создаваемые программистом) и демоны.
- Основной поток запускается автоматически и отвечает за выполнение метода `main()`.
- Пользовательские потоки можно создавать из основного потока, и они выполняются параллельно ему.
- Основной поток обычно завершается последним, выполняя различные операции завершения, такие как закрытие потоков ввода-вывода и соединений с базами данных.

#### Потоки-демоны
- Потоки-демоны работают в фоновом режиме, выполняя вспомогательные операции (например, сборка мусора).
- Демоны автоматически завершаются, когда все пользовательские потоки завершили свое выполнение.
- Потоки-демоны обычно имеют низкий приоритет и используются для фоновых операций, таких как ввод-вывод или сетевое взаимодействие.

#### Создание и использование потоков-демонов

##### Получение имени текущего потока
```java
public class App {
    public static void main(String[] args) {
        var threadName = Thread.currentThread().getName();
        System.out.println("Thread that is executing: " + threadName);
    }
}
```
- Этот код иллюстрирует использование метода `Thread.getName()`, который возвращает имя текущего выполняющегося потока.

##### Пример с потоком-демоном
```java
public class App {
    public static void main(String[] args) {
        var worker = new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            var threadName = Thread.currentThread().getName();
            System.out.println("Thread is finishing its execution with name: " + threadName);
        }, "Worker");

        var daemon = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                var threadName = Thread.currentThread().getName();
                System.out.println("Thread is executing with name: " + threadName);
            }
        }, "Daemon");

        daemon.setDaemon(true);
        worker.start();
        daemon.start();

        var threadName = Thread.currentThread().getName();
        System.out.println("Thread is executing with name: " + threadName);
    }
}
```
- В этом примере `worker` выполняет задачу и завершается, в то время как `daemon` продолжает выполняться в бесконечном цикле.
- Установка потока как демона (`daemon.setDaemon(true)`) означает, что он будет автоматически завершен, когда все пользовательские потоки завершат свою работу.
- `setDaemon(true)` должен вызываться до запуска потока; иначе будет выброшено `IllegalThreadStateException`.

#### Общие принципы работы с потоками в Java
- Важно понимать разницу между пользовательскими потоками и демонами, особенно когда это влияет на процесс завершения приложения.
- Потоки-демоны полезны для выполнения фоновых задач, но не следует использовать их для критически важных операций, поскольку они могут быть неожиданно завершены.
- Управление жизненным циклом потоков важно для корректной работы многопоточных приложений.


## Синхронизация потоков в Java

### Проблемы многопоточности
- Последовательность выполнения действий в разных потоках может привести к неожиданным результатам.
- Параллельный доступ к общим ресурсам без должной синхронизации может вызвать гонки данных (race conditions) и привести к неправильному поведению программы.
- Взаимные блокировки и неравномерное распределение ресурсов между потоками могут снижать производительность и приводить к ошибкам.

### Синхронизация потоков
- Синхронизация в Java предоставляет механизмы для упорядочивания доступа потоков к общим ресурсам.
- Ключевое слово `synchronized` используется для определения блоков кода или методов, которые должны быть защищены от одновременного доступа нескольких потоков.

#### Методы синхронизации
1. **Модификатор `synchronized` для методов:**
   ```java
   public synchronized void method() {
       // Тело метода
   }
   ```
   Когда поток вызывает синхронизированный метод, он захватывает монитор объекта (или класса, если метод статический).

2. **Синхронизированный блок внутри методов:**
   ```java
   public void method() {
       synchronized(this) {
           // Тело синхронизированного блока
       }
   }
   ```
   Синхронизированный блок позволяет уточнить объект, монитор которого будет использован для блокировки.

### Примеры синхронизации
#### Проблема синхронизации счётчика
- Рассмотрим проблему, когда несколько потоков инкрементируют одну и ту же переменную. Без синхронизации конечное значение переменной будет непредсказуемым из-за race conditions.

#### Синхронизация с использованием `synchronized`
- Добавление `synchronized` к методу `increaseCounter` гарантирует, что каждый поток будет увеличивать счетчик последовательно, обеспечивая правильный итоговый результат.

### Потокобезопасные классы в Java
- Java предлагает потокобезопасные версии стандартных коллекций (например, `Vector`, `ConcurrentHashMap`), которые обеспечивают автоматическую синхронизацию при доступе к элементам коллекции из разных потоков, тем самым упрощая разработку многопоточных приложений.

### Понятие монитора в контексте Java
- Каждый объект в Java имеет связанный с ним монитор, который помогает управлять доступом к синхронизированным блокам кода.
- Монитор объекта содержит внутренние механизмы для управления блокировкой, ожиданием и уведомлением потоков.

#### Внутреннее устройство монитора
- Мониторы в Java содержат внутренние механизмы для управления доступом потоков, включая механизмы ожидания и уведомления (`wait()`, `notify()`, `notifyAll()`).

### Пример использования мониторов и синхронизированных блоков
Рассмотрим более сложный пример, демонстрирующий использование синхронизированных блоков с разными объектами-мониторами для разных частей кода:

```java
class Example {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            // Код, требующий синхронизации с использованием lock1
        }
    }

    public void method2() {
        synchronized(lock2) {
            // Код, требующий синхронизации с использованием lock2
        }
    }
}
```

В этом примере `method1` и `method2` могут выполняться параллельно, так как они синхронизированы на разных объектах.

### Потокобезопасность и атомарные операции
- Некоторые операции в Java являются атомарными (например, чтение и запись примитивных типов, за исключением `long` и `double`), что означает, что они выполняются в одном шаге без возможности прерывания.
- Использование ключевого слова `volatile` гарантирует, что чтение и запись переменной происходит напрямую в память, обеспечивая таким образом видимость изменений между разными потоками.

### Избегание блокировок (Deadlocks)
- Важно проектировать многопоточные приложения таким образом, чтобы избежать взаимных блокировок, когда два или более потоков ждут ресурсы, захваченные друг другом, создавая тем самым состояние вечного ожидания.

### Рекомендации по синхронизации
- Используйте синхронизацию экономно, чтобы не снизить производительность приложения.
- При проектировании многопоточных приложений всегда учитывайте возможность возникновения состояний гонки, взаимных блокировок и других проблем многопоточности.
- Изучайте и используйте высокоуровневые абстракции и утилиты для многопоточности из пакета `java.util.concurrent`, которые могут помочь упростить разработку многопоточных приложений и сделать ее более надежной.

# Многопоточность в Java с использованием java.util.concurrent

С появлением Java 1.5 был введён пакет `java.util.concurrent`, который представляет собой мощный инструментарий для разработки многопоточных приложений. Этот пакет содержит набор классов для реализации многопоточности, включая синхронизаторы и параллельные коллекции, обеспечивающие более высокий уровень абстракции по сравнению с традиционными методами синхронизации.

## Синхронизаторы

### 1. `Semaphore`
- **Описание**: Управляет доступом к ресурсу, используя счётчик разрешений.
- **Конструкторы**:
   - `Semaphore(int permits)`
   - `Semaphore(int permits, boolean fair)`
- **Методы**:
   - `acquire()`, `acquire(int permits)`
   - `release()`, `release(int permits)`

#### Пример кода с `Semaphore`:
```java
Semaphore sem = new Semaphore(1);
sem.acquire();
// действия с общим ресурсом
sem.release();
```

### 2. `CountDownLatch`
- **Описание**: Позволяет потокам ожидать, пока не произойдёт определённое количество событий.
- **Конструктор**: `CountDownLatch(int count)`
- **Методы**: `await()`, `countDown()`

#### Пример кода с `CountDownLatch`:
```java
CountDownLatch latch = new CountDownLatch(3);
// в других потоках
latch.countDown();
latch.await();
// продолжение работы после завершения всех событий
```

### 3. `CyclicBarrier`
- **Описание**: Позволяет группе потоков ожидать друг друга в определённой точке исполнения.
- **Конструкторы**:
   - `CyclicBarrier(int parties)`
   - `CyclicBarrier(int parties, Runnable barrierAction)`
- **Метод**: `await()`

### 4. `Exchanger`
- **Описание**: Позволяет двум потокам обменяться данными.
- **Метод**: `exchange(V x)`

### 5. `Phaser`
- **Описание**: Синхронизирует потоки, проходящие через несколько фаз.
- **Конструкторы**: `Phaser()`, `Phaser(int parties)`
- **Методы**: `arrive()`, `arriveAndAwaitAdvance()`

## Параллельные коллекции

Представляют собой потокобезопасные версии коллекций, позволяющие безопасно работать с ними из нескольких потоков.

### Примеры коллекций:
- `ConcurrentHashMap`
- `CopyOnWriteArrayList`
- `ConcurrentLinkedQueue`

## Исполнители (Executors)

Позволяют управлять потоками на более высоком уровне, чем работа напрямую с объектами `Thread`.

### Типы исполнителей:
- `ExecutorService` - управляет пулом потоков.
- `ScheduledExecutorService` - позволяет планировать выполнение задач.

#### Пример кода с использованием `ExecutorService`:
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> {
    // ваш код
});
executor.shutdown();
```

## Рекомендации по использованию

1. Внимательно выбирайте тип пула потоков в зависимости от задачи.
2. Явно завершайте работу пулов потоков, используя метод `shutdown()`.
3. Избегайте ситуаций, когда задачи в пуле ожидают завершения друг друга, чтобы предотвратить взаимную блокировку.

