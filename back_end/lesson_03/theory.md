# Lesson 03

### Введение в системы сборки

- **Зачем нужны системы сборки**: Упрощают процесс разработки, компиляции, тестирования и развертывания приложений, минимизируя ручные усилия и улучшая согласованность и надежность процессов.
- **Эволюция систем сборки**: От простых скриптов до сложных систем, которые управляют зависимостями, процессами сборки и деплоймента.

### Различие между JAR и WAR

- **JAR vs. WAR**: JAR для автономных приложений или библиотек, WAR для веб-приложений, развертываемых на серверах.

### Системы сборки для Java

1. **Apache Ant**:
    - **Ориентирован на гибкость**: Позволяет разработчикам определять структуру сборки через XML, но может привести к сложности для больших проектов.
    - **Пример `build.xml`**: Демонстрирует, как задаются цели (targets) для различных этапов сборки проекта.

2. **Apache Maven**:
    - **Структурированный и конвенциональный подход**: Устанавливает стандартную структуру проекта и автоматизирует управление зависимостями.
    - **POM.xml**: Центральный файл конфигурации, определяющий проект, его зависимости, плагины и другие параметры.

3. **Gradle**:
    - **Гибкость и производительность**: Использует DSL на базе Groovy для конфигурации, позволяя более гибкое определение сборки.
    - **Пример `build.gradle`**: Показывает настройку сборки, объединяя простоту конфигурации с мощными возможностями.

### Пример создания приложения с Maven

1. **Создание проекта**:
    - Инициализация стандартной структуры проекта Maven с помощью команды архетипа.

2. **Добавление зависимости**:
    - Демонстрация подключения внешней библиотеки (Gson) через POM.xml.

3. **Использование библиотеки в коде**:
    - Пример использования Gson для сериализации и десериализации объектов Java в JSON и обратно.

4. **Сборка и выполнение проекта**:
    - Описание процесса компиляции, тестирования и упаковки приложения в JAR-файл с помощью Maven, а затем выполнение собранного приложения.

### Для создания JAR-файла в IntelliJ IDEA:

1. **Откройте проект в IntelliJ IDEA**: Запустите IntelliJ IDEA и откройте ваш проект.

2. **Настройка артефакта JAR**: Перейдите в меню `File` > `Project Structure` (или нажмите `Ctrl+Alt+Shift+S`). В открывшемся окне выберите `Artifacts` в левом меню, затем нажмите на зеленый плюс (`+`) и выберите `JAR` > `From modules with dependencies...`.

3. **Выбор модуля и точки входа**: В появившемся окне выберите модуль и укажите точку входа вашего приложения (класс, который содержит метод `main`). Нажмите `OK`.

4. **Настройка структуры JAR**: Вы можете настроить структуру JAR, добавив или исключив определенные файлы и директории. После настройки нажмите `OK`.

5. **Сборка артефакта**: Перейдите в меню `Build` и выберите `Build Artifacts...`. Затем выберите ваш артефакт и нажмите `Build`.

6. **Проверка сгенерированного JAR**: После сборки IntelliJ IDEA создаст JAR-файл в указанной вами директории. Вы можете найти этот файл и проверить его содержимое.

7. **Запуск JAR-файла**: Чтобы проверить, работает ли ваш JAR-файл, откройте терминал, перейдите в директорию, содержащую JAR-файл, и запустите его, используя команду `java -jar имя_файла.jar`.


# Базовые принципы программирования

### DRY (Don’t Repeat Yourself)

**Описание:** Этот принцип подчеркивает важность избегания дублирования кода. Повторение одних и тех же участков кода может привести к ошибкам, усложнению поддержки и обновления программы.

**Комментарий:** DRY помогает сделать код более чистым, модульным и легким для тестирования. Реализация этого принципа часто достигается за счет использования функций, классов и наследования.

**Пример на Java:**
```java
// Не следующий принципу DRY
public void processUserData(String userName) {
    System.out.println("Processing data for: " + userName);
    // Логика обработки...
}

public void processBillingData(String userName) {
    System.out.println("Processing billing for: " + userName);
    // Логика обработки...
}

// Следующий принципу DRY
public void processUser(String userName, String type) {
    System.out.println("Processing " + type + " for: " + userName);
    // Логика обработки...
}
```

### KISS (Keep It Simple, Stupid)

**Описание:** Этот принцип подчеркивает важность поддержания простоты в коде. Простые решения часто более надежны и понятны.

**Комментарий:** KISS способствует тому, чтобы разработчики не усложняли логику без необходимости, что упрощает дальнейшую поддержку и понимание кода.

**Пример на Java:**
```java
// Сложный и запутанный код
public int calculate(int a, int b) {
    // Ненужно сложная логика...
    return a * b + a - b; // Просто для примера
}

// Простой и понятный код
public int add(int a, int b) {
    return a + b;
}
```

### SOLID
-	Single responsibility principle (принцип единственной ответственности).
-	Open-closed principle (принцип открытости/закрытости).
-	Liskov substitution principle (принцип подстановки Лисков).
-	Interface segregation principle (принцип разделения интерфейса).
-   Dependency inversion principle (принцип инверсии зависимостей).


1. **Single Responsibility Principle (SRP):** Принцип персональной ответственности.

   ```java
   // Нарушает SRP
   public class User {
       public void saveToDatabase() { /* ... */ }
       public void updateUserSettings() { /* ... */ }
   }

   // Следует SRP
   public class User { /* ... */ }
   public class UserRepository { public void save(User user) { /* ... */ } }
   public class UserSettings { public void updateSettings(User user) { /* ... */ } }
   ```

2. **Open-Closed Principle (OCP):** Классы должны быть открыты для расширения, но закрыты для модификации.

   ```java
   public abstract class Shape {
       public abstract double area();
   }

   public class Rectangle extends Shape {
       private double width;
       private double height;

       public double area() {
           return width * height;
       }
   }

   public class Circle extends Shape {
       private double radius;

       public double area() {
           return Math.PI * radius * radius;
       }
   }
   ```

3. **Liskov Substitution Principle (LSP):** Подклассы должны быть заменяемы на их базовые классы.

   ```java
   public class Bird {
       public void fly() { /* ... */ }
   }

   public class Duck extends Bird { /* ... */ }
   public class Ostrich extends Bird {
       @Override
       public void fly() {
           throw new UnsupportedOperationException("Ostrich cannot fly");
       }
   }
   ```

4. **Interface Segregation Principle (ISP):** Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют.

```java
public interface Worker {
    void work();
    void eat();
}

// Разделяем интерфейс на более мелкие части
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public class HumanWorker implements Workable, Eatable {
    public void work() {
        // Работа
    }

    public void eat() {
        // Еда
    }
}

public class RobotWorker implements Workable {
    public void work() {
        // Работа
    }
}
```

5. **Dependency Inversion Principle (DIP):** Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций.

```java
public interface Database {
    void save(Object data);
}

public class MySQLDatabase implements Database {
    public void save(Object data) {
        // Сохранение данных в MySQL
    }
}

public class UserService {
    private Database database;

    public UserService(Database database) {
        this.database = database;
    }

    public void saveUser(User user) {
        database.save(user);
    }
}
```

### YAGNI (You Aren’t Gonna Need It)

**Описание:** Не добавляйте функциональность, пока она действительно не нужна. Это помогает избежать излишней сложности и сосредоточиться на текущих требованиях.

**Комментарий:** YAGNI предостерегает от соблазна проектировать систему с возможностями, которые "могут понадобиться в будущем", но на самом деле часто так и остаются неиспользованными.



### Оверинжиниринг (overengineering) — 

Зто процесс проектирования продукта или системы с излишне сложными или неоправданно продвинутыми функциями. Это может проявляться в чрезмерной генерализации, использовании избыточных технологий или в создании решений, которые далеко выходят за рамки текущих требований. Давайте подробнее рассмотрим аспекты и причины оверинжиниринга, а также способы его избежать.

### Аспекты оверинжиниринга

1. **Избыточная сложность:** Разработка решений, которые слишком сложны для текущей проблемы, может привести к увеличению времени разработки, тестирования и поддержки.

2. **Предвосхищение будущих потребностей:** Разработчики иногда пытаются предвидеть будущие функции или требования, добавляя в систему расширяемость, которая в действительности может никогда не понадобиться.

3. **Использование передовых технологий без необходимости:** Применение новейших или самых сложных технологий может быть неоправданным, если более простые решения могут эффективно решить ту же задачу.

### Причины оверинжиниринга

1. **Перфекционизм:** Желание создать идеальное решение, которое сможет удовлетворить любые потенциальные требования в будущем.

2. **Недостаток понимания требований:** Неясность или неполное понимание текущих требований может побуждать разработчиков вводить дополнительную функциональность "на всякий случай".

3. **Стремление использовать новые технологии:** Иногда разработчики могут использовать новые инструменты или языки программирования для решения задач, даже если это неоправданно с точки зрения требований проекта.

### Способы избежания оверинжиниринга

1. **YAGNI (You Aren’t Gonna Need It):** Сосредоточьтесь на реализации функциональности, которая действительно требуется в данный момент, избегая добавления функций "на будущее".

2. **Простота:** Следуйте принципу KISS (Keep It Simple, Stupid), стремясь к тому, чтобы дизайн и реализация были как можно проще.

3. **Итеративная разработка:** Использование методологий агильной разработки может помочь сосредоточиться на текущих задачах и постепенно добавлять функциональность в соответствии с изменяющимися требованиями.

4. **Рефакторинг:** Регулярно пересматривайте и упрощайте код, избавляясь от избыточной сложности и устаревших решений.

5. **Понимание бизнес-требований:** Тесное взаимодействие с заинтересованными сторонами и понимание бизнес-целей могут помочь в создании решений, которые точно соответствуют необходимым требованиям.

Оверинжиниринг может привести к увеличению стоимости и времени разработки, усложнению поддержки и обслуживания программного продукта, а также к уменьшению его надежности. 

### Способы избежания оверинжиниринга

6. **Проведение код-ревью:** Регулярные код-ревью могут помочь идентифицировать случаи оверинжиниринга, поскольку другие разработчики могут указать на излишнюю сложность или предложить более простые решения.

7. **Ограничение области ответственности:** Соблюдение принципов, таких как Single Responsibility Principle из SOLID, помогает избежать создания "божественных объектов", которые пытаются делать слишком много всего сразу.

8. **Минимализм в проектировании:** Стремитесь к минимализму в архитектуре и дизайне программных решений, избегая предварительного добавления структур, которые не несут немедленной пользы.

### Последствия оверинжиниринга

1. **Увеличение затрат:** Оверинжиниринг может существенно увеличить затраты на разработку и поддержку продукта, поскольку излишне сложные решения требуют больше времени и ресурсов.

2. **Затруднение поддержки и расширения:** Избыточно сложный код может стать проблемой при необходимости его изменения, обновления или расширения функциональности.

3. **Увеличение риска ошибок:** Чем сложнее система, тем выше вероятность возникновения ошибок в процессе ее разработки и использования.

4. **Снижение производительности:** Излишне сложные решения могут отрицательно сказаться на производительности программного продукта.

### Примеры оверинжиниринга

- **Создание обобщенной системы:** Разработка универсальной системы для решения специфической проблемы, которая в действительности требует простого и целенаправленного подхода.

- **Преждевременная оптимизация:** Затраты усилий на оптимизацию частей системы, которые не являются узкими местами производительности, ведет к ненужной работе и усложнению кода.

- **Использование сложных паттернов:** Применение архитектурных паттернов там, где они не нужны, может привести к неоправданному усложнению архитектуры программного решения.

В заключение, оверинжиниринг — это ловушка, в которую легко попасть в погоне за идеальным решением. Ключ к успешной разработке — это баланс между достаточной простотой для удовлетворения текущих требований и достаточной гибкостью для будущего расширения, не забывая при этом о качестве и поддерживаемости кода.
