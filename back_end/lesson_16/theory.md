## Spring Security

## 01. Безопасность в приложении

* Аутентификация - процесс, при котором приложение запрашивает логин и пароль и проверяет их корректность
  * проверка подлинности данных пользователя
* Авторизация - процесс, при котором приложение проверяет права пользователя на выполнение каких-либо операций
  * например, проверка на возможность получения пользователем всех курсов по адресу `/courses`
* HTTP-сессия - это некоторый объект, который мы храним на сервере, с которым может быть ассоциирован конкретный пользователь

## 02. Процесс аутентификации на основе сессии

* Сначала клиент отправляет POST-запрос на сервер по адресу `api/login`
* В теле запроса клиент передает данные для аутентификации (например, email и пароль)
* Сервер проверяет корректность этих данных (находит пользователя в базе, хеширует введенный пароль, сравнивает с тем, который есть в базе)
* Если данные для входа корректные, то сервер в оперативной памяти создает объект сессии
  * ассоциирует с этим объектом данные пользователя
  * назначает объекту идентификатор
  * отправляет клиенту этот идентификатор, который на клиенте сохраняется в куках

## 03. Процесс авторизации на основе сессии

* Клиент посылает свой запрос вместе с кукой, которая содержит идентификатор сессии
* Сервер по этому идентификатору находит сессию в хранилище и получает ее атрибуты (в нашем случае это пользователь)
* Получив пользователя, сервер проверяет его роль и доступ к определенному endpoint на основе правил (опишем далее)
* Клиенту возвращается либо запрошенный ресурс, либо 403-статус (Запрещено)


## 04. Настройка безопасности Spring Boot с Spring Security

* При подключении Spring Boot Starter Security у вас есть:
  * Страница входа
  * Защита всех endpoints
  * Логин `user`
  * Пароль генерируется в консоли
* Но мы хотим, чтобы люди заходили под своими логинами и паролями

### Шаги по настройке Spring Security


1. Создать класс-реализацию интерфейса `UserDetails`
  * Данный класс нужен для того, чтобы адаптировать вашего пользователя под безопасность Spring Security
  * По сути, это адаптер нашего класса `User` для `Spring Security`
2. Создать класс-реализацию интерфейса `UserDetailsService`
  * Данный класс нужен для того, чтобы показать Spring Security откуда брать пользователя для проверки
3. Настройка конфигурации Spring Security 
4. Навести порядок с ответами на запросы


### Правильные ответы на неправильные запросы

### Что происходит сейчас?

1. Если мы не аутентифицированы, то к нам приходит страница логина на запросы 
  * Это плохо, потому что у нас для этих случаев будет работать frontend, он сам покажет нужную страницу
  * Нам просто нужно в JSON-ответе указать, что запрос не аутентифицирован и мы не можем дать доступ и указать статус `401`

# Продолжение Spring Security

## 01. Замечания

* Конфигурация Security в Spring-приложении сводится к тому, чтобы получить готовый бин `HttpSecurity`, донастроить его и на его основе сделать новый бин - `SecurityFilterChain`
* Важно: поскольку мы хотим минимизировать количество кода для настройки и понимания Spring Security, мы сделали одно допущение (оставили по-умолчанию):
  * Запрос `POST /login` уходит как обычная HTTP/HTML-форма, а не JSON.

## 02. Внесение определенных изменений в конфигурацию

* Для удобства сделали метод `fillResponse`
* Мы заметили, что после того, как мы делаем `login`, сервер отдает нам информацию от запроса, который до этого не был авторизован
  * Это не очень хорошее поведение, мы бы хотели, чтобы после `login` вам просто приходило сообщение в формате JSON о том, что вы успешно вошли в приложение
  * Аналогичным образом, мы бы хотели просто сообщить пользователю в JSON, если он ввел некорректный логин или пароль
  * Аналогично для `logout`
* Поскольку настройка `/login` и `/logout` выполняется не в контроллерах (а в фильтрах), то Swagger не может зацепить эти url-ы и показать их в документации
  * Чтобы их добавить, нам необходимо прописать это "ручками"
  * Добавить мой класс `OpenApiDocumentation`
  * Добавить бин `OpenAPI` в класс с `main`

## 03. Добавление новых функций

* Получение информации о себе на основе сессии 
* Разграничение по ролям
  * `.antMatchers("/api/users").hasAnyAuthority("ADMIN")` - мы говорим, что запрос с этим URL может выполнять только пользовать с ролью `ADMIN`
  * `.antMatchers("/api/users").hasAnyAuthority("ADMIN", "USER")` - если разрешаете нескольким ролям
  * `.antMatchers("/api/users/**").hasAnyAuthority("ADMIN", "USER")` - если устанавливаете ограничение на все ENDPOINTS, которые начинаются с `api/users
  * `.antMatchers(HttpMethod.POST, "/api/users/**").hasAnyAuthority("ADMIN", "USER")` - разрешили отправлять POST-запросы на все URL-ы, которые начинаются с `api/users` только `ADMIN` и `USER`
* 
* Более красивый способ разграничения по ролям:
  * `@PreAuthorize("hasAuthority('ADMIN')")` - данную аннотацию вешаем на метод контроллера (или можно на весь контроллер)

## 04. Настройка Swagger


## 05. Автоконфигурация Spring


# Spring Security (продолжение)

* `Aутентификация` - идентификация пользователя, кто ты?

* `Авторизация` - проверка прав пользователя, какие действия ты можешь выполнять?

* `Authentication` - объект, который хранит для каждого запроса информацию о пользователе и статусе его аутентификации.

* `SecurityContext` - информация о безопасности, которая ассоциирована с текущим потоком исполнения (Thread). Хранит объект Authentication.

* `SecurityContextHolder` - привязывает SecurityContext к текущему потоку исполнения. По умолчанию ThreadLocal - контекст безопосности доступен всем методам, исполняемым в рамках данного потока.

* Т.е. когда приходит запрос на сервер, сервер выделяет ему один поток из `Tomcat Thread Pool`
* Далее, SecurityContextHolder (на самом деле фильтры, но это не важно) смотрит текущую сессию и привязывает объект `Authentication` к текущему потоку исполнения
* Далее, когда запрос приходит в какой-либо контроллер или хендлер - он уже приходит с объектом аутентификации

